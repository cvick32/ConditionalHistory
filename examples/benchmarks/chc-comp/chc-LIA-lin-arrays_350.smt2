(set-logic HORN)
(declare-fun state ((Array Int Int) Int Int Int Int Int Int Int) Bool)
(assert (forall ((|A_0| (Array Int Int)) (|B_0| Int) (|C_0| Int) (|D_0| Int) (|E_0| Int) (|F_0| Int) (|G_0| Int) (|H_0| Int) (|.x.5| Int) (|.x.4| Int) (|.x.3| Int) (|.x.2| Int) (|.x.1| Int) (|H| Int) (|K| (Array Int Int)) (|.xpv.1| Int)) (=> (and (and (and (and (= B_0 1) (not (<= C_0 0))) (= D_0 1)) (= F_0 7)) (= E_0 3)) (state |A_0| |B_0| |C_0| |D_0| |E_0| |F_0| |G_0| |H_0|))))
(assert (forall ((|A_0| (Array Int Int)) (|B_0| Int) (|C_0| Int) (|D_0| Int) (|E_0| Int) (|F_0| Int) (|G_0| Int) (|H_0| Int) (|.x.5| Int) (|.x.4| Int) (|.x.3| Int) (|.x.2| Int) (|.x.1| Int) (|H| Int) (|K| (Array Int Int)) (|.xpv.1| Int)) (=> (and (state |A_0| |B_0| |C_0| |D_0| |E_0| |F_0| |G_0| |H_0|) (let ((.def_58 (ite (<= G_0 F_0) (store A_0 (+ (* 3 B_0) (- 3)) F_0) (store A_0 (+ (* 3 B_0) (- 3)) 0)))) (let ((.def_62 (ite (<= G_0 E_0) (store .def_58 (+ (* 3 B_0) (- 2)) E_0) (store .def_58 (+ (* 3 B_0) (- 2)) 0)))) (and (= G_0 .x.5) (and (= F_0 .x.4) (and (= E_0 .x.3) (and (= D_0 .x.2) (and (= C_0 .x.1) (and (= (+ B_0 (* (- 1) H)) (- 1)) (and (<= B_0 C_0) (= (ite (<= G_0 D_0) (store .def_62 (+ (* 3 B_0) (- 1)) D_0) (store .def_62 (+ (* 3 B_0) (- 1)) 0)) K))))))))))) (state |K| |H| |.x.1| |.x.2| |.x.3| |.x.4| |.x.5| |.xpv.1|))))
(assert (forall ((|A_0| (Array Int Int)) (|B_0| Int) (|C_0| Int) (|D_0| Int) (|E_0| Int) (|F_0| Int) (|G_0| Int) (|H_0| Int) (|.x.5| Int) (|.x.4| Int) (|.x.3| Int) (|.x.2| Int) (|.x.1| Int) (|H| Int) (|K| (Array Int Int)) (|.xpv.1| Int)) (=> (state |A_0| |B_0| |C_0| |D_0| |E_0| |F_0| |G_0| |H_0|) (let ((.def_79 (select A_0 H_0))) (not (and (and (<= 0 H_0) (and (and (not (<= B_0 C_0)) (not (= .def_79 0))) (not (<= G_0 .def_79)))) (not (<= (+ (* 3 C_0) (* (- 1) H_0)) 0))))))))
(check-sat)
