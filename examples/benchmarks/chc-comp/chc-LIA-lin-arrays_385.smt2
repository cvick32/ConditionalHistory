(set-logic HORN)
(declare-fun state ((Array Int Int) Int Int Bool Int) Bool)
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (and (= B_1 0) (not .loc.2)) (state |A_1| |B_1| |C_0| |.loc.2| |D_1|))))
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (and (state |A_1| |B_1| |C_0| |.loc.2| |D_1|) (let ((.def_17 (not .loc.2))) (let ((.def_24 (<= C_0 B_1))) (let ((.def_34 (not .def_24))) (let ((.def_40 (= (+ B_1 (* (- 1) v_3)) (- 1)))) (and (= C_0 .x.3) (or (and (or (and .def_17 (and (and (= v_3 2) .def_24) (= A_1 .x.2))) (and (= .x.2 (store A_1 B_1 (* 2 (select A_1 B_1)))) (and (and .loc.2 .def_34) .def_40))) .loc.3) (and (= .x.2 (store A_1 B_1 B_1)) (and (not .loc.3) (and .def_40 (and .def_17 .def_34))))))))))) (state |.x.2| |v_3| |.x.3| |.loc.3| |.xpv.1|))))
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (state |A_1| |B_1| |C_0| |.loc.2| |D_1|) (not (and .loc.2 (and (and (<= C_0 B_1) (and (not (<= D_1 0)) (not (<= (+ (* 2 D_1) (* (- 1) (select A_1 D_1))) 0)))) (not (<= C_0 D_1))))))))
(check-sat)
