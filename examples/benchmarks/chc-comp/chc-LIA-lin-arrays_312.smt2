(set-logic HORN)
(declare-fun state ((Array Int Int) Int Int Bool Int) Bool)
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (and (= B_1 0) (not .loc.2)) (state |A_1| |B_1| |C_0| |.loc.2| |D_1|))))
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (and (state |A_1| |B_1| |C_0| |.loc.2| |D_1|) (let ((.def_17 (not .loc.2))) (let ((.def_23 (<= C_0 B_1))) (let ((.def_33 (not .def_23))) (let ((.def_39 (= (+ B_1 (* (- 1) v_3)) (- 1)))) (and (= C_0 .x.3) (or (and (or (and .def_17 (and (and (= v_3 0) .def_23) (= A_1 .x.2))) (and (= .x.2 (store A_1 B_1 (+ B_1 (select A_1 B_1)))) (and (and .loc.2 .def_33) .def_39))) .loc.3) (and (= .x.2 (store A_1 B_1 B_1)) (and (not .loc.3) (and .def_39 (and .def_17 .def_33))))))))))) (state |.x.2| |v_3| |.x.3| |.loc.3| |.xpv.1|))))
(assert (forall ((|A_1| (Array Int Int)) (|B_1| Int) (|C_0| Int) (|.loc.2| Bool) (|D_1| Int) (|.x.3| Int) (|v_3| Int) (|.x.2| (Array Int Int)) (|.loc.3| Bool) (|.xpv.1| Int)) (=> (state |A_1| |B_1| |C_0| |.loc.2| |D_1|) (not (and .loc.2 (and (and (and (<= C_0 B_1) (not (<= D_1 0))) (<= 0 (+ (* 2 D_1) (* (- 1) (select A_1 D_1))))) (not (<= C_0 D_1))))))))
(check-sat)
